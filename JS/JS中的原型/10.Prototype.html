<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>prototype</title>
    <script>
        //每个function都有一个默认的属性prototype，而这个prototype的constructor默认指向这个函数
        //注意Person.constructor 不等于 Person.prototype.constructor. Function实例自带constructor属性
      /*  function Person(name) {
            this.name = name;
        }
        Person.prototype.getName = function () {
            return this.name;
        };
        var p = new Person("ass");
        console.log(Person.prototype.constructor === Person);// true
        console.log(p.__proto__ === Person.prototype); //true
        console.log(p.constructor === Person); //// true ,这是因为p本身不包含constructor属性，所以这里其实调用的是Person.prototype.constructor
*/
        /*

        * 我们的目的是要表示
         1.表明Person继承自Animal
         2.表明p2是Person的实例

         我们修改一下prototype属性的指向，让Person能获取Animal中的prototype属性中的方法。也就是Person继承自Animal(人是野兽)
         */
        function Person(name) {
            this.name = name;
        }
        Person.prototype.getName = function() {
            return this.name;
        };

        var p1 = new Person("ass");
        console.log(p1.constructor === Person);
        console.log(Person.prototype.constructor === Person);

        function Animal(age){
            this.age = 28;
        }
        Person.prototype = new Animal();////之所以不采用Person.prototype  = Animal.prototype,是因为new 还有其他功能，最后总结。
        Person.prototype.constructor = Person;
        var p2 = new Person("ass");
        console.log(p2.constructor === Person);
        //console.log(p2.constructor === Animal);
        console.log(p2.age);
/*???????????????????????????????????????????????????????????????????????*/
    </script>
</head>
<body>

</body>
</html>